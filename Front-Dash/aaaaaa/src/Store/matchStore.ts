import axiosInstance from './axiosConfig';

// Define the base URL for your backend fixture API
// Ensure this matches where your backend is running (protocol, host, port)
const API_BASE_URL = 'http://localhost:5000/fixture';

// Define the structure of a Team reference based on your Mongoose matchSchema
interface TeamRef {
  _id?: string; // Mongoose ID (optional on create)
  id?: number;  // Team's numeric ID (ensure consistency if used)
  code?: string;
  name?: string;
  logo?: string;
}

// Define the structure for goal information based on matchSchema
interface GoalInfo {
  halftime?: number; // Optional, defaults to 0 on backend
  fulltime?: number; // Optional, defaults to 0 on backend
}

// Define the main structure of a Fixture (Match) based on your Mongoose matchSchema
// This interface should align with the data returned by your API and stored in the DB
export interface Fixture {
  _id?: string;         // Mongoose document ID, generated by DB, useful for GET/PUT/DELETE
  id?: number;          // The separate numeric 'id' field in your schema (use carefully to avoid confusion with _id)
  referee?: string;
  round: string;        // Required
  date: string;         // Store and transfer as ISO string (e.g., "2024-04-20T18:00:00.000Z") or "YYYY-MM-DD"
  stadename: string;    // Required
  stadecity: string;    // Required
  teamshome: TeamRef;   // Required structure
  teamsaway: TeamRef;   // Required structure
  statuslong?: string;  // Optional, defaults on backend
  statusshort?: string; // Optional, defaults on backend
  goalshome?: GoalInfo; // Optional structure
  goalsaway?: GoalInfo; // Optional structure
}

// Type for data used when CREATING a fixture.
// Omits fields generated by the backend (_id) or having defaults.
// Make required fields non-optional here based on backend validation.
// NOTE: This structure MUST match what your `POST /fixture` endpoint expects.
// You will need to MAP your `PlayerForm` data from Match.tsx TO this structure.
export type CreateFixtureData = {
    referee?: string;
    round: string;
    date: string; // Ensure format is correct (e.g., ISO string)
    stadename: string;
    stadecity: string;
    // Represent teams based on how your backend expects them (e.g., just IDs or full objects)
    // Assuming backend expects basic info or IDs to lookup/embed:
    teamshome: { id?: number; name: string; logo?: string; code?: string; /* add other necessary fields */ };
    teamsaway: { id?: number; name: string; logo?: string; code?: string; /* add other necessary fields */ };
    // Optional fields with defaults usually aren't sent on creation
    // statuslong?: string;
    // statusshort?: string;
    // goalshome?: GoalInfo;
    // goalsaway?: GoalInfo;
};


// Type for data used when UPDATING a fixture (often allows partial updates).
// NOTE: This structure MUST match what your `PUT /fixture/:id` endpoint expects.
// You will need to MAP your `PlayerForm` data from Match.tsx TO this structure.
export type UpdateFixtureData = Partial<Omit<Fixture, '_id'>>;


// --- API Service Functions ---

/**
 * Fetches all fixtures from the backend.
 * Corresponds to: GET /fixture
 * @returns Promise<Fixture[]> - A promise resolving to an array of fixtures.
 */
export const getAllFixtures = async (): Promise<Fixture[]> => {
  try {
    // The backend wraps the array in a 'data' property
    const response = await axiosInstance.get<{ data: Fixture[]; status: string }>(API_BASE_URL);
    console.log("API Response (getAllFixtures):", response.data); // Log for debugging
    // Ensure the expected structure is returned
    if (response.data && Array.isArray(response.data.data)) {
        return response.data.data;
    } else {
        console.error("Unexpected response format from GET /fixture:", response.data);
        return []; // Return empty array as a fallback
    }
  } catch (error) {
    console.error('Error fetching all fixtures:', error);
    throw error; // Re-throw error to be handled by the calling component (e.g., show error message)
  }
};

/**
 * Fetches a single fixture by its Mongoose _id.
 * Corresponds to: GET /fixture/:id
 * @param id The Mongoose _id of the fixture to fetch.
 * @returns Promise<Fixture | null> - A promise resolving to the fixture or null if not found.
 */
export const getFixtureById = async (id: string): Promise<Fixture | null> => {
    if (!id) {
        console.error("getFixtureById requires a valid ID.");
        return null; // Or throw an error
    }
  try {
    // Backend wraps the single object in a 'data' property
    const response = await axiosInstance.get<{ data: Fixture; status: string }>(`${API_BASE_URL}/${id}`);
    console.log(`API Response (getFixtureById ${id}):`, response.data);
    return response.data.data;
  } catch (error) {
    console.error(`Error fetching fixture with id ${id}:`, error);
    // Check if it's a 404 error (Not Found)
    if (axiosInstance.isAxiosError(error) && error.response?.status === 404) {
        return null; // Return null if the fixture doesn't exist
    }
    throw error; // Re-throw other errors
  }
};

/**
 * Creates a new fixture on the backend.
 * Corresponds to: POST /fixture
 * @param fixtureData - The data for the new fixture.
 * >>> IMPORTANT <<< : This data object MUST be correctly structured and mapped
 * >>> from your frontend form data (`PlayerForm`) BEFORE being passed to this function.
 * >>> The keys and values must match the backend `matchSchema` and `createFixture` expectations.
 * @returns Promise<Fixture> - A promise resolving to the newly created fixture (including its _id).
 */
export const createFixture = async (fixtureData: CreateFixtureData): Promise<Fixture> => {
    console.log("Sending data to createFixture:", fixtureData); // Log data being sent

    // --- MAPPING REQUIRED HERE ---
    // You MUST transform the data from your `Match.tsx` state (`formData` which uses `PlayerForm` type)
    // into the `CreateFixtureData` structure expected by the backend API.
    // Example (You need to adapt this based on your actual backend needs):
    /*
    const backendReadyData: CreateFixtureData = {
        referee: formData.team_id, // This mapping is likely WRONG based on labels! Review!
        round: formData.team_code, // This mapping is likely WRONG!
        date: formData.date,       // Ensure this is in a format the backend accepts (e.g., ISO string)
        stadename: formData.team_name, // Likely WRONG mapping!
        stadecity: formData.team_logo, // Likely WRONG mapping!
        teamshome: {
            name: formData.name, // Likely WRONG mapping! Map Home Team Name correctly
            // You need to get/pass Home Team ID, logo, code etc.
        },
        teamsaway: {
             name: formData.age, // Likely WRONG mapping! Map Away Team Name correctly
            // You need to get/pass Away Team ID, logo, code etc.
        }
        // Map other fields as needed...
    };
    */
   // If `fixtureData` passed in is ALREADY correctly mapped, proceed:
  try {
    // Backend returns the created object wrapped in 'data'
    const response = await axiosInstance.post<{ data: Fixture; status: string }>(API_BASE_URL, fixtureData /* Use backendReadyData here after mapping */);
    console.log("API Response (createFixture):", response.data);
    return response.data.data;
  } catch (error) {
    console.error('Error creating fixture:', error);
     // Log detailed validation errors if the backend provides them
    if (axiosInstance.isAxiosError(error) && error.response?.data) {
        console.error("Backend Error Data:", error.response.data);
    }
    throw error;
  }
};

/**
 * Updates an existing fixture by its Mongoose _id.
 * Corresponds to: PUT /fixture/:id
 * @param id - The Mongoose _id of the fixture to update.
 * @param fixtureData - An object containing the fields to update.
 * >>> IMPORTANT <<< : This data object MUST be correctly structured and mapped
 * >>> from your frontend form data (`PlayerForm`) BEFORE being passed to this function.
 * >>> Keys should match the backend `matchSchema`.
 * @returns Promise<Fixture> - A promise resolving to the updated fixture.
 */
export const updateFixture = async (id: string, fixtureData: UpdateFixtureData): Promise<Fixture> => {
    if (!id) {
        console.error("updateFixture requires a valid ID.");
        throw new Error("Update requires a valid fixture ID.");
    }
    console.log(`Sending data to updateFixture ${id}:`, fixtureData); // Log data being sent

    // --- MAPPING REQUIRED HERE ---
    // Similar to createFixture, map your frontend `formData` (PlayerForm)
    // to the `UpdateFixtureData` structure before sending.

  try {
    // Backend returns the updated object wrapped in 'data'
    const response = await axiosInstance.put<{ data: Fixture; status: string }>(`${API_BASE_URL}/${id}`, fixtureData /* Use mapped data */);
    console.log("API Response (updateFixture):", response.data);
    return response.data.data;
  } catch (error) {
    console.error(`Error updating fixture with id ${id}:`, error);
     if (axiosInstance.isAxiosError(error) && error.response?.data) {
        console.error("Backend Error Data:", error.response.data);
    }
    throw error;
  }
};

/**
 * Deletes a fixture by its Mongoose _id.
 * Corresponds to: DELETE /fixture/:id
 * @param id - The Mongoose _id of the fixture to delete.
 * @returns Promise<void> - A promise that resolves when deletion is successful.
 */
export const deleteFixture = async (id: string): Promise<void> => {
    if (!id) {
        console.error("deleteFixture requires a valid ID.");
        throw new Error("Delete requires a valid fixture ID.");
    }
  try {
    // Backend might return the deleted object in 'data', but we often don't need it frontend.
    const response = await axiosInstance.delete<{ data: Fixture; status: string }>(`${API_BASE_URL}/${id}`);
    console.log(`API Response (deleteFixture ${id}):`, response.data); // Log success
  } catch (error) {
    console.error(`Error deleting fixture with id ${id}:`, error);
    throw error;
  }
};

// Optional: Add functions for other specific backend routes if needed
// Example: updateStatus
/*
export const updateFixtureStatus = async (id: string, statusShort: string): Promise<Fixture> => {
    try {
        const response = await axios.put<{ data: Fixture; status: string }>(
            `${API_BASE_URL}/${id}/status`,
            { status: statusShort } // Backend expects { status: '...' } in body
        );
        return response.data.data;
    } catch (error) {
        console.error(`Error updating status for fixture ${id}:`, error);
        throw error;
    }
};
*/